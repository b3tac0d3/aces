<?php 

namespace aces;
use PDO;
use PDOException;
use error_handler\load_errors;

class query extends db{
    
    /*==================================================================================================================
        Variables
    ==================================================================================================================*/

    // Main table name | string
    private $table;

    // Main table alias | string 
    private $alias;
    
    // Column list ready for query string | string | code generated
    private $columns;

    // List of columns maintained throughout run for updating column list string | string
    private $columns_list;

    // Querty string join statment | string
    private $joins_stmt;

    // Execute array join values | array
    private $joins_array;

    // Query string where statement | string
    private $where_stmt;

    // Execute array where values | array
    private $where_array;
    
    // Primary grouping | string
    private $group;
    
    // Primary ordering | string
    private $order;
    
    // Start and limit | string
    private $limit;
    
    // PDO::FETCH type
    private $execute = array();
    
    // PDO fetch mode | command
    private $fetch;
    
    // MySQL results array
    private $results;
    
    // Boolean to return single top row or multiple rows
    private $fetch_solo;
    
    // Complete query string to be executed | string
    private $query_string;
    
    // PDO query method | object
    private $query;

    // Type of query currently being setup to execute | string
    private $query_type;

    // List of values to be inserted | string
    private $insert_list;

    // Insert values ready to be added to prepared statement | string
    private $insert_sql_string;

    // Last insert id as generated by PDO | int
    private $lastInsertId;

    // Query rowCount()
    private $row_count;

    // Class stored as new class
    private $error_handler;

    // Log class
    private $log;

    // Databse object
    private $db;

    /*==================================================================================================================
        Logging
    ==================================================================================================================*/

    private $query_start_time;

    private $query_end_time;

    private $query_run_time;

    /*==================================================================================================================
        Debug vars
    ==================================================================================================================*/

    // Switch to check if debug_me should be checked
    private $debug_mode = false;
    
    // Show current query string instead of executing
    private $show_my_query_string;

    // Stop after debug options have been executed
    private $debug_stop_mode = false;

    // Return string containing all requested debug values
    private $debugged;

    /*==================================================================================================================
        Query Methods
    ==================================================================================================================*/

    function __construct(){
        $this -> db = $this -> connect();
        //$this -> error_handler = new load_errors();
        $this -> log = new log();
        $this -> set_fetch();
    } // __construct()

    function select($table, $alias = null){
        $this -> query_type = "select";
        $this -> alias = $alias;
        return $this -> run_select_query($table);
    } // select()

    function insert($table, $audit_table_log_note = null){
        $this -> query_type = "insert";
        return $this -> run_insert_query($table, $audit_table_log_note);
    } // insert()

    function update($table){
        $this -> query_type = "update";
        return $this -> run_update_query($table);
    } // update()

    function delete($table){
        $this -> query_type = "delete";
        return $this -> run_delete_query($table);
    } // delete()

    function deactivate($table, $row_id){
        // This function is specifically designed to deactivate rows and log the delete while keeping the record
        // Consider this a "soft delete"
        $this -> query_type = "deactivate";
        return $this -> run_deactivate_query($table, $row_id);
    } // deactivate()

    function custom($query, $params = array()){
        $this -> query_string = $query;
        $this -> execute = $params;
        $this -> query -> execute($this -> execute);
        $this -> results = $this -> query -> fetchAll($this -> fetch);
        $this -> lastInsertId = $this -> db -> lastInsertId();
        return $this -> results;
    } // custom()

    /*==================================================================================================================
        Query Setup
    ==================================================================================================================*/

    function set_join($table, $alias = null, $ons_array = array(), $type = "INNER"){
        /* on_vals array should be array("u.id = l.user_id", ) */

        // Check / set where-execute-array if not exists
        if(empty($this -> joins_array)) $this -> joins_array = array();
        if(empty($ons_array)) $this -> error_handler -> mk_error("dev", "Function set_join of database/query.php file is missing comparison values. Check use of input function.");
        if(empty($ons)) $ons = "";

        foreach($ons_array as $k => $v){
            $ons .= "$k = $v";
            // if(!empty($v)) array_push($this -> joins_array, $on[1]);
            if(next($ons_array)) $ons .= "AND ";
        }
        // find non-relational on conditions and bind to execute array
        $this -> joins_stmt .= "$type JOIN $table $alias ON $ons ";
        
        return $this;
    } // set_join()

    function set_where($column, $value, $operator = "=", $logical_operator = "AND "){
        
        if(empty($this -> where_stmt)){
            $this -> where_stmt = "WHERE ";
        }else{
            $this -> where_stmt = $this -> where_stmt . "$logical_operator ";
        }

        if(empty($this -> where_array)) $this -> where_array = array();

        $where_factor = "? ";
        
        // If value is an array, it's either for BETWEEN or IN statement
        if(!is_array($value)) $value = explode(",", $value);

        if($operator == "BETWEEN"){
            $where_factor = "? AND ? ";
            array_push($this -> where_array, $value[0], $value[1]);
        }elseif($operator == "IN"){
            $where_factor = "(". join(',', array_fill(0, count($value), '?')) . ")";
            $this -> where_array = array_merge($this -> where_array, $value);
        }else{
            array_push($this -> where_array, $value[0]);
        }
        
        $this -> where_stmt .= "$column $operator $where_factor";
        
        return $this;
    } // set_where()

    function set_where_array($columns, $values){
        // Push an array of where statements but only for = operator
        // Alternative statements with BETWEEN or IN will still have to be set individually
        foreach($columns as $k => $v) $this -> set_where($v, $values[$k]);
        return $this;
    }

    function set_group($column){
        if(empty($this -> group)){
            $this -> group = "GROUP BY ";
        }else{
            $this -> group = "," . $this -> group;
        }
        $this -> group .= $column;
        return $this;
    } // set_group()

    function set_order($column, $order){
        if(empty($this -> order)){
            $this -> order = "ORDER BY ";
        }else{
            $this -> order = "," . $this -> order;
        }
        if(empty($sort = $order)) $sort = "ASC ";
        $this -> order .= "$column $sort ";
        return $this;
    } // set_sort()

    function set_limit($start, $limit){
        $this -> limit = "LIMIT $start, $limit";
        return $this;
    } // set_limit()
    
    function set_select_column($column = null){
        if(empty($column)){
            $this -> columns = "*";
        }else{
            if(!empty($this -> columns)) $this -> columns .= ",";
            $this -> columns .= $column;
        }
        return $this;
    } // set_select_columns()

    function set_select_array($columns){
        foreach($columns as $c){
            $this -> set_select_column($c);
        }
        return $this;
    } // set_select_array

    function set_update_column($column, $value = null){
        if(!empty($this -> columns_list)) $this -> columns_list .= ",";
        if(!empty($this -> insert_list)) $this -> insert_list .= ",";
        
        $this -> columns_list .= "$column = ?";

        array_push($this -> execute, $value);
        
        $this -> columns = "{$this -> columns_list}";
        return $this;
    } // set_update_columns()

    function set_update_array($columns, $values){
        // The key difference is that this accpets multiple values as arrays
        // Columns = arry and values = array
        // These are associative based on key (ie cols = user, pass, active ?? vals = user, pass, 1)

        foreach($columns as $key => $val) $this -> set_update_column($val, $values[$key]);

        return $this;
    } // set_update_columns()

    function set_insert_column($column, $value=null){
        // INSERT INTO {$this -> table} {$this -> columns} VALUES {$this -> insert_sql_string}
        // $this -> insert_sql_string must be surrounded by parenthases - reset every time something is added to insert_list
        // $this -> insert_list maintains a running list of question marks to represent variables in execute_array
        
        if(!empty($this -> columns_list)) $this -> columns_list .= ",";
        if(!empty($this -> insert_list)) $this -> insert_list .= ",";
        
        $this -> columns_list .= $column;
        $this -> insert_list .= "?";

        array_push($this -> execute, $value);
        
        $this -> columns = "({$this -> columns_list})";
        $this -> insert_sql_string = "({$this -> insert_list})";
        
        return $this;
    } // set_insert_column()

    function set_insert_array($columns, $values){
        // The key difference is that this accpets multiple values as arrays
        // Columns = arry and values = array
        // These are associative based on key (ie cols = user, pass, active ?? vals = user, pass, 1)

        foreach($columns as $key => $val) $this -> set_insert_column($val, $values[$key]);

        return $this;
    } // set_insert_columns()

    function set_alias($alias){
        $this -> alias = $alias;
        return $this;
    } // set_alias()

    function set_fetch($fetch_solo = 0, $fetch = PDO::FETCH_ASSOC){
        // Default is to return all records
        // Return all records or just a single record
        if($fetch_solo == 0)
            $this -> fetch_solo = false;
        else
            $this -> fetch_solo = true;

        // Set the PDO fetch type. Accepts all values
        $this -> fetch = $fetch;

        return $this;
    } // set_return()

    function dev_debug($type, $stop = true){
        if($stop == true) $this -> debug_stop_mode = true;
        $this -> debug_mode = true;
        
        switch($type){
            case "show_query_string":
            case "SQS": // ShowQueryString
                $this -> show_my_query_string = true;
                break;
        }
    } // dev_debug()

    function get_lastInsertId(){
        return $this -> lastInsertId;
    } // get_lastInsertId()


    function get_results(){
        return $this -> results;
    } // get_results()

    function get_rowCount(){
        return $this -> row_count;
    } // get_rowCount()

    /*==================================================================================================================
        Class Control Methods
    ==================================================================================================================*/

    private function run_select_query($table){
        // Prepare query and do pre-checks
        $this -> pre_query($table);
        
        // If no columns were entered, default to all columns
        if(empty($this -> columns)) $this -> set_select_column();
        
        // Prepare the proper query string
        $this -> query_string = "SELECT {$this -> columns} FROM {$this -> table} {$this -> alias} {$this -> joins_stmt} {$this -> where_stmt} {$this -> group} {$this -> order} {$this -> limit}";
        
        // Debugging
        // var_dump($this -> query_string);exit;
        
        // Run query
        $this -> execute_query();

        // Get the proper results to return to user
        $this -> row_count = $this -> query -> rowCount();
        if($this -> fetch_solo == true){
            $this -> results = $this -> query -> fetch($this -> fetch);
        }else{
            $this -> results = $this -> query -> fetchAll($this -> fetch);
        }

        return $this -> results;
    } // run_select_query()

    private function run_insert_query($table, $audit_table_log_note = null){
        // Prepare query and do pre-checks
        $this -> pre_query($table);

        // If no columns are set to insert, we can't continue
        if(empty($this -> columns)) $this -> error_handler -> mk_error("dev", "No values set to insert.");
        
        // Prepare the proper query string
        $this -> query_string = "INSERT INTO {$this -> table} {$this -> columns} VALUES {$this -> insert_sql_string}";
        
        // Run query
        $this -> execute_query();

        // Get the proper results to return to the user
        $this -> results = array(
            "status" => 1,
            "last_insert_id" => $this -> db -> lastInsertId()
        );

        // Get last insert id for logging and db record purposing
        $this -> lastInsertId = $this -> db -> lastInsertId();

        // Add to database record logs
        if(aces_db_record_logging_edits == true && !str_contains($this -> table, "log_")){
            // FOR NOW, THIS FEATURE IS SOLELY RELYING ON THE USE OF THE TERM "LOG_" TO DEFINE LOG TABLES.
            // IN THE FUTURE, CONSIDER CREATING A LIST OF LOG TABLES TO REFERENCE INSTEAD.
            $audit = new query_audits();
            $audit -> audit_db_record_create($this -> table, $this -> lastInsertId, $audit_table_log_note);
        }

        return $this -> results;
    } // run_insert_query

    private function run_update_query($table){
        // Prepare query and do pre-checks
        $this -> pre_query($table);

        // If no columns are set to update, we can't continue
        if(empty($this -> columns)) $this -> error_handler -> mk_error("dev", "No values set to update.");

        // Prepare the proper query string
        $this -> query_string = "UPDATE {$this -> table} SET {$this -> columns} {$this -> where_stmt}";

        // Run query
        $this -> execute_query();

        // Get the proper results to return to the user
        $this -> results = array("status" => 1);
        
        return $this -> results;
    } // run_update_query

    private function run_delete_query($table){
        // Prepare query do do pre-checks
        $this -> pre_query($table);

        // Prepare the proper query string
        $this -> query_string = "DELETE FROM {$this -> table} {$this -> where_stmt}";

        // Run query
        $this -> execute_query();

        // Get the proper results to return to the user
        $this -> results = array("status" => 1);
        
        return $this -> results;
    } // run_delete_query

    private function run_deactivate_query($table, $row_id){
        // Prepare the proper query string with the only where statement needed
        $this -> set_where("id", $row_id);

        // Prepare query do do pre-checks
        $this -> pre_query($table);

        // Prepare the query string
        $this -> query_string = "UPDATE {$this -> table} SET active = 0 {$this -> where_stmt}";
        
        // Run query
        $this -> execute_query();
        
        // Log the results in the record life table
        // DON'T FORGET TO ADD CHECKING FOR DATABASE LOGGING TRUE TO BE ON
        $audit = new query_audits();
        $audit -> audit_db_record_delete($table, $row_id);

        return $this -> results;
    } // run_deactivate_query

    private function run_custom_query($table){
        
    }

    private function pre_query($table){
        // Absolute
        if(empty($this -> table = $table)) $this -> error_handler -> mk_error("dev", "select query has empty table name");
        if(!empty($this -> joins_array)) $this -> execute = array_merge($this -> execute, $this -> joins_array);
        if(!empty($this -> where_array)) $this -> execute = array_merge($this -> execute, $this -> where_array);

        return $this;
    } // pre_query()


    private function execute_query(){
        // Final prep on the query string to translate to query
        $this -> query = $this -> db -> prepare(trim($this -> query_string));
        
        // Attempt to run final query
        try{
            // Capture query start time for tracking
            $this -> query_start_time = microtime(true);
            
            // Run query
            $this -> query -> execute($this -> execute);

            // Get query run time
            $this -> query_end_time = microtime(true);
            $this -> query_run_time = $this -> query_end_time - $this -> query_start_time;

        }catch (PDOException $e){
            $this -> log -> set_record("query_error", [
                "error" => trim($e -> getMessage()),
                "query_string" => preg_replace(array('/\s{2,}/', '/[\t\n]/'), ' ', $this -> dumpSQLQuery($this -> query_string, $this -> execute))
            ]);
            echo "<br><br><b><i>ACES Error</i>: " . $e -> getMessage() . "</b>";
            exit;
        } // try

        // Post query results handling and query logging
        $this -> row_count = $this -> query -> rowCount();

        // Log query if applicable
        if(aces_log_status_query == true){
            $log_data_array = array(
                "table" => $this -> table,
                "result_count" => $this -> row_count,
                "run_time" => round($this -> query_run_time, 5) . "s",
                "query_string" => preg_replace(array('/\s{2,}/', '/[\t\n]/'), ' ', $this -> dumpSQLQuery($this -> query_string, $this -> execute))
            );
            $this -> log -> set_record("query", $log_data_array);
        }

        return $this;
    } // execute_query()

    /*==================================================================================================================
        Debugging
    ==================================================================================================================*/

    private function debug_me(){
        if($this -> show_my_query_string == true) $this -> debugged .= "<b>Final Query String: <i>" . $this -> query . "</i></b><br>";
        echo $this -> debugged;
        //if($this -> debug_stop_mode == true) exit();
    } // debug_me()


    private function dumpSQLQuery($string,$data) {
        $indexed = $data == array_values($data);
        foreach($data as $k => $v) {
            // These two line are to eliminate deprication errors for passing null values to second arg of preg_replace in PHP 8.1+
            if(empty($v) && is_string($v)) $v = "";
            if(empty($v)) $v = 0;
            
            if(is_string($v)) $v = "'$v'";
            if($indexed) $string = preg_replace('/\?/',$v,$string,1);
            else $string = str_replace(":$k",$v,$string);
        }
        return $string;
    }
} // class query
?>